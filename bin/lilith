#!/usr/bin/env perl

use strict;
use warnings;
use Getopt::Long;
use Lilith;
use TOML        qw(from_toml);
use File::Slurp qw(read_file);

sub version {
	print "lilith v. 0.0.1\n";
}

sub help {
	&version;

	print '

--config <ini>     Config INI file.
                   Default :: /usr/local/etc/lilith.ini

-a <action>        Action to perform.
                   Default :: search

Action :: run
Description :: Runs the ingestion loop.

Action :: create_tables
Description :: Creates the tables in PostgreSQL.

Action :: search
Description :: Searches the specified table returns the results.

-r <return>      Return type. Either table or json.
                 Default: table

--si <src ip>    Source IP.
                 Default :: undef

--di <dst ip>    Destination IP.
                 Default :: undef

--sp <src port>  Source port.
                 Default :: undef

--dp <dst port>  Destination port.
                 Default :: undef

--ip <ip>        IP, either dst or src.
                 Default :: undef

--p <port>       Port, either dst or src.
                 Default :: undef

--id <alert id>  Alert ID.
                 Default :: undef

-t <table>      Table to search. suricata/sagan
                Default :: suricata

--host <host>   Host.
                Default :: undef

--hl            Use like for matching host.
                Default :: undef

-i <host>       Instance.
                Default :: undef

--il            Use like for matching instance.
                Default :: undef

-C <classification> Classification.
                    Default :: undef

-Cl             Use like for matching classification.
                Default :: undef

-d <dsc>        Alert description.
                Default :: undef

-dl             Use like for matching alert.
                Default :: undef
';
}

# get the commandline options
my $help        = 0;
my $version     = 0;
my $config_file = '/usr/local/etc/lilith.toml';
my $rules_file  = '/usr/local/etc/lilith_rules.toml';
my $action      = 'search';
my $return_type = 'table';
my $src_ip;
my $dst_ip;
my $src_port;
my $dst_port;
my $alert_id;
my $table = 'suricata';
my $host;
my $host_like;
my $instance_host;
my $instance_host_like;
my $instance;
my $instance_like;
my $class;
my $class_like;
my $signature;
my $signature_like;
my $ip;
my $port;
my $go_back_minutes = 5;
my $in_iface;
my $in_iface_like;
my $proto;
my $app_proto;
my $app_proto_like;
my $gid;
my $sid;
my $rev;
Getopt::Long::Configure('no_ignore_case');
Getopt::Long::Configure('bundling');
GetOptions(
	'version'  => \$version,
	'v'        => \$version,
	'help'     => \$help,
	'h'        => \$help,
	'config=s' => \$config_file,
	'r=s'      => \$rules_file,
	'a=s'      => \$action,
	'si=s'     => \$src_ip,
	'sp=s'     => \$src_port,
	'di=s'     => \$dst_ip,
	'dp=s'     => \$dst_port,
	'id=s'     => \$alert_id,
	't=s'      => \$table,
	'h=s'      => \$host,
	'hl'       => \$host_like,
	'ihl'      => \$instance_host_like,
	'ih=s'     => \$instance_host,
	'i=s'      => \$instance,
	'il'       => \$instance_like,
	'c=s'      => \$class,
	'cl'       => \$class_like,
	's=s'      => \$signature,
	'sl'       => \$signature_like,
	'ip=s'     => \$ip,
	'p=s'      => \$port,
	'm=s'      => \$go_back_minutes,
	'if=s'     => \$in_iface,
	'il'       => \$in_iface_like,
	'proto=s'  => \$proto,
	'ap=s'     => \$app_proto,
	'apl'      => \$app_proto_like,
	'gid=s'    => \$gid,
	'sid=s'    => \$sid,
	'rev=s'    => \$rev,

);

# print version or help if requested
if ($help) {
	&help;
	exit 42;
}
if ($version) {
	&version;
	exit 42;
}

if ( !defined($action) ) {
	die('No action defined via -a');
}

# make sure the file exists
if ( !-f $config_file ) {
	die( '"' . $config_file . '" does not exist' );
}

# read the in or die
my $toml_raw = read_file($config_file) or die 'Failed to read "' . $config_file . '"';

# read the specified config
my ( $toml, $err ) = from_toml($toml_raw);
unless ($toml) {
	die "Error parsing toml,'" . $config_file . "'" . $err;
}

my $lilith=Lilith->new(
					   dsn      => $toml->{dsn},
					   sagan    => $toml->{sagan},
					   suricata => $toml->{suricata},
					   user     => $toml->{user},
					   pass     => $toml->{pass},
					   );

# create the tables if requested
if ( $action eq 'create_tables' ) {
	$lilith->create_tables();
	exit;
}

my %files;
my @toml_keys = keys( %{$toml} );
my $int       = 0;
while ( defined( $toml_keys[$int] ) ) {
	my $item = $toml_keys[$int];

	if ( ref( $toml->{$item} ) eq "HASH" ) {

		# add the file in question
		$files{$item} = $toml->{$item};
	}

	$int++;
}

# default to a empty rule set if the file does not exist
my $rules_toml = {};
if ( -f $rules_file ) {

	# read the rule toml in or die
	my $rule_toml_raw = read_file($rules_file) or die 'Failed to read "' . $rules_file . '"';

	# read the specified rules
	my ( $rules_toml, $rule_err ) = from_toml($rule_toml_raw);
	unless ($rules_toml) {
		die "Error parsing toml,'" . $rules_file . "'" . $rule_err;
	}
}

if ( $action eq 'run' ) {
	$lilith->run(
		files    => \%files,
	);
}

if ( $action eq 'extend' ) {
	$lilith->extend(

	);
}

if ( $action eq 'search' ) {
	my $returned = Lilith->search(
		dsn                => $toml->{dsn},
		sagan              => $toml->{sagan},
		suricata           => $toml->{suricata},
		user               => $toml->{user},
		pass               => $toml->{pass},
		src_ip             => $src_ip,
		src_port           => $src_port,
		dst_ip             => $dst_ip,
		ip                 => $ip,
		port               => $port,
		alert_id           => $alert_id,
		table              => $table,
		host               => $host,
		host_like          => $host_like,
		instance_host      => $instance_host,
		instance_host_like => $instance_host_like,
		instance           => $instance,
		instance_like      => $instance_like,
		class              => $class,
		class_like         => $class_like,
		signature          => $signature,
		signature_like     => $signature_like,
		ip                 => $ip,
		port               => $port,
		app_proto          => $app_proto,
		app_proto_like     => $app_proto_like,
		proto              => $proto,
		gid                => $gid,
		sid                => $sid,
		rev                => $rev,
	);
	print $returned;
}
