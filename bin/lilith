#!/usr/bin/env perl

use strict;
use warnings;
use Getopt::Long;
use Lilith;
use TOML        qw(from_toml);
use File::Slurp qw(read_file);

sub version {
	print "lilith v. 0.0.1\n";
}

sub help {
	&version;

	print '

-c <ini>     Config INI file.
             Default :: /usr/local/etc/lilith.ini

-a <action>  Action to perform.
             Default :: search

Action :: run
Description :: Runs the ingestion loop.

Action :: create_tables
Description :: Creates the tables in PostgreSQL.

Action :: search
Description :: Searches the specified table returns the results.

-r <return>      Return type. Either table or json.
                 Default: table

--si <src ip>    Source IP.
                 Default :: undef

--di <dst ip>    Destination IP.
                 Default :: undef

--sp <src port>  Source port.
                 Default :: undef

--dp <dst port>  Destination port.
                 Default :: undef

--ip <ip>        IP, either dst or src.
                 Default :: undef

--p <port>       Port, either dst or src.
                 Default :: undef

--id <alert id>  Alert ID.
                 Default :: undef

-t <table>      Table to search. suricata/sagan
                Default :: suricata

--host <host>   Host.
                Default :: undef

--hl            Use like for matching host.
                Default :: undef

-i <host>       Instance.
                Default :: undef

--il            Use like for matching instance.
                Default :: undef

-C <classification> Classification.
                    Default :: undef

-Cl             Use like for matching classification.
                Default :: undef

-d <dsc>        Alert description.
                Default :: undef

-dl             Use like for matching alert.
                Default :: undef
';
}

# get the commandline options
my $help        = 0;
my $version     = 0;
my $config_file = '/usr/local/etc/lilith.toml';
my $rules_file  = '/usr/local/etc/lilith_rules.toml';
my $action      = 'search';
my $return_type = 'table';
my $src_ip;
my $dst_ip;
my $src_port;
my $dst_port;
my $alert_id;
my $table = 'suricata';
my $host;
my $host_like;
my $instance;
my $instance_like;
my $class;
my $class_like;
my $desc;
my $desc_like;
my $ip;
my $port;
my $go_back_minutes = 5;
my $in_iface;
my $in_iface_like;
my $proto;
my $app_proto;
my $app_proto_like;
Getopt::Long::Configure('no_ignore_case');
Getopt::Long::Configure('bundling');
GetOptions(
	'version' => \$version,
	'v'       => \$version,
	'help'    => \$help,
	'h'       => \$help,
	'c=s'     => \$config_file,
	'r=s'     => \$rules_file,
	'a=s'     => \$action,
	'si=s'    => \$src_ip,
	'sp=s'    => \$src_port,
	'di=s'    => \$dst_ip,
	'dp=s'    => \$dst_port,
	'id=s'    => \$alert_id,
	't=s'     => \$table,
	'h=s'     => \$host,
	'hl'      => \$host_like,
	'i=s'     => \$instance,
	'il'      => \$instance_like,
	'C=s'     => \$class,
	'Cl'      => \$class_like,
	'd=s'     => \$desc,
	'dl'      => \$desc_like,
	'ip=s'    => \$ip,
	'p=s'     => \$port,
		   'm=s'     => \$go_back_minutes,
		   'if=s' =>\$in_iface,
		   'il' =>\$in_iface_like,
		   'proto=s' =>\$proto,
		   'ap=s'=>\$app_proto,
		   'apl'=>\$app_proto_like,

);

# print version or help if requested
if ($help) {
	&help;
	exit 42;
}
if ($version) {
	&version;
	exit 42;
}

if ( !defined($action) ) {
	die('No action defined via -a');
}

# make sure the file exists
if ( !-f $config_file ) {
	die( '"' . $config_file . '" does not exist' );
}

# read the in or die
my $toml_raw = read_file($config_file) or die 'Failed to read "' . $config_file . '"';

# read the specified config
my ( $toml, $err ) = from_toml($toml_raw);
unless ($toml) {
	die "Error parsing toml,'" . $config_file . "'" . $err;
}

# create the tables if requested
if ( $action eq 'create_tables' ) {
	Lilith->create_tables(
		dsn      => $toml->{dsn},
		sagan    => $toml->{sagan},
		suricata => $toml->{suricata},
		user     => $toml->{user},
		pass     => $toml->{pass},
	);
	exit;
}

my %files;
my @toml_keys = keys( %{$toml} );
my $int       = 0;
while ( defined( $toml_keys[$int] ) ) {
	my $item = $toml_keys[$int];

	if ( ref( $toml->{$item} ) eq "HASH" ) {

		# add the file in question
		$files{$item} = $toml->{$item};
	}

	$int++;
}

# default to a empty rule set if the file does not exist
my $rules_toml = {};
if ( !-f $rules_file ) {

	# read the rule toml in or die
	my $rule_toml_raw = read_file($rules_file) or die 'Failed to read "' . $rules_file . '"';

	# read the specified rules
	my ( $rules_toml, $rule_err ) = from_toml($rule_toml_raw);
	unless ($rules_toml) {
		die "Error parsing toml,'" . $rules_file . "'" . $rule_err;
	}
}

if ( $action eq 'run' ) {
	Lilith->run(
		dsn      => $toml->{dsn},
		sagan    => $toml->{sagan},
		suricata => $toml->{suricata},
		user     => $toml->{user},
		pass     => $toml->{pass},
		files    => \%files,
	);
}

if ( $action eq 'extend' ) {
	Lilith->extend(
		dsn      => $toml->{dsn},
		sagan    => $toml->{sagan},
		suricata => $toml->{suricata},
		user     => $toml->{user},
		pass     => $toml->{pass},
	);
}

if ( $action eq 'search' ) {
	my $returned = Lilith->search(
		dsn           => $toml->{dsn},
		sagan         => $toml->{sagan},
		suricata      => $toml->{suricata},
		user          => $toml->{user},
		pass          => $toml->{pass},
		src_ip        => $src_ip,
		src_port      => $src_port,
		dst_ip        => $dst_ip,
		ip            => $ip,
		port          => $port,
		alert_id      => $alert_id,
		table         => $table,
		host          => $host,
		host_like     => $host_like,
		instance      => $instance,
		instance_like => $instance_like,
		class         => $class,
		class_like    => $class_like,
		desc          => $desc,
		desc_like     => $desc_like,
		ip            => $ip,
		port          => $port,
	);
	print $returned;
}
